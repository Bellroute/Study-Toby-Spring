# 2장 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 **객체지향** 과 **테스트** 라고 대답할 것이다. 스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있는 기술. 동시에 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술. 

이러한 복잡한 애플리케이션을 개발하는 데 필요한 도구 하나는 객체지향 기술이고 다른 하나의 도구는 스프링이 강조하고 가치를 두고 있는 테스트이다.

애플리케이션은 계속 변하고 복잡해져 간다. 변화에 대응하는

- 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담을 수 있는 IoC/DI 같은 기술이라면,
- 두 번째 전략은 <u>만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는</u> 테스트 기술이다.

테스트는 스프링을 학습하는 데 있어 가장 효과적인 방법의 하나임. 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

→ 2장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴봄. + 테스트 프레임워크와 이를 활용한 학습 전략

---

#### [INDEX]

**2.1 [UserDaoTest 다시 보기](https://github.com/Bellroute/Study-Toby-Spring/blob/master/summary/chapter02_%ED%85%8C%EC%8A%A4%ED%8A%B8.md#21-userdaotest-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EA%B8%B0)**

**2.2. [UserDaoTest 개선](https://github.com/Bellroute/Study-Toby-Spring/blob/master/summary/chapter02_%ED%85%8C%EC%8A%A4%ED%8A%B8.md#22-userdaotest-%EA%B0%9C%EC%84%A0)**

</br>

## 2.1 UserDaoTest 다시 보기

### 2.1.1 테스트의 유용성

1장에서 만든 UserDao가 기대했던 대로 동작하는지 확인하기 위해 간단한 테스트 코드를 만들었다. 테스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로 기능이 동작하는지를 매 단계 확인한 덕분에, 다양한 방법으로 초난감 UserDao 코드의 설계와 코드를 개선했고, 심지어 스프링을 적용해서 동작하게 만들 수도 있었다. 

테스트를 통해 확인할 수 없었다면, 그 코드를 개선하는 과정 내내 뭔가 꺼림칙하고 불안했을 것이다. 코드를 들여다보며 머릿속으로 시뮬레이션하는 방법이 있긴 하지만 그것만으로는 100% 확신할 수 없다.

테스트란 결국 **내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업** 이다. 테스트 결과가 원하는 대로 나오지 않은 경우, 코드나 설계에 결함이 있음을 알고 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

</br>

### 2.1.2 UserDaoTest 특징

1장에서 만들었던 main() 메소드로 작성된 테스트 코드를 다시 한번 살펴보자.

```java
public class UserDaoTest {

    public static void main(String[] args) throws SQLException {
        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);

        User user = new User();
        user.setId("bellroot");
        user.setName("벨루트");
        user.setPassword("1234");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());

        System.out.println(user2.getId() + " 조회 성공");
    }
}
```

이 테스트 코드의 내용을 정리하면 다음과 같다.

- 자바에서 가장 쉽게 실행 가능한 main() 메소드를 이용함
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출함
- 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어줌
- 테스트의 결과를 콘솔에 출력함
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력함

가장 돋보이는 건, main() 메소드를 이용해 테스트 수행을 가능하게 했다는 점과 테스트할 대상인 UserDao를 직접 호출해서 사용한다는 점

#### 웹을 통한 DAO 테스트 방법의 문제점

보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. 

DAO를 만든 뒤, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤......(이하 생략)

이렇게 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 DAO에 대한 테스트로서는 단점이 너무 많음. DAO 뿐만 아니라 필요한 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다. 테스트 도중 에러가 나거나 실패하면 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요함.

→ **하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문.** 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식의 테스트는 번거롭고, 오류가 있을 때 빠르고 정확한 대응이 어렵다.

#### 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직함. 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 함. 관심사의 분리라는 원리가 여기에도 적용 됨. **테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 함.**

UserDaoTest는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다. 간단히 IDE나 도스창에서도 테스트 수행이 가능함. 에러가 나거나 원치 않는 결과가 나온다면, UserDao 코드나 DB 연결 방법 정도에서 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있음.

이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트(unit test)** 라고 한다. 

- 여기서 말하는 단위는 크기와 범위가 딱 정해진 것이 아니라 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.

- 단위는 작을수록 좋다. 단위를 넘어서는 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.
- 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라 보기도 한다. 
  - DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 UserDaoTest는 단위 테스트로서 가치가 없어짐.

때로는 각 단위 기능은 잘 동작하는데 묶어놓으면 안 되는 경우가 종종 발생하기 때문에, 웹 사용자 인터페이스로부터 시작해 DB에 이르기까지 애플리케이션 전 계층이 참여하는 등 길고 많은 단위가 참여하는 테스트도 언젠가는 필요함.

<u>단위 테스트 없이 긴 테스트만 하게 되면</u> 수많은 에러를 만나거나 에러는 안 나지만 제대로 기능이 동작하지 않는 경험을 하게 될 것이다. 이 때는 <u>문제의 원인을 찾기가 매우 힘들다.</u> 만약 각 단위별로 테스트를 먼저 진행하고 나서 이런 긴 테스트를 시작했다면 역시 예외가 발생하거나 테스트가 실패하더라도, 이미 각 단위별로 충분한 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.

단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 테스터나 고객이 테스트를 하는 시점이면 이미 개발자가 코드를 작성하고 나서 한참 뒤일 것. 그때서야 오류가 처음 발견되고 개발자에게 문제가 통보된다면 개발자는 오래 전에 만든 코드를 뒤져서 버그를 수정해야 한다.

#### 자동수행 테스트 코드

UserDaoTest의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다. User 오브젝트를 만들어 적절한 값을 넣고, 이미 DB 연결 준비까지 다 되어 있는 UserDao 오브젝트를 스프링 컨테이너에서 가져와서 add() 메소드를 호출하고, 그 키 값으로 get()을 호출하는 것까지 자동으로 진행됨. 번거롭게 매번 입력할 필요도 없고, 테스트를 시작하기 위해 서버를 띄우고, 브라우저를 열어야 하는 불편함도 없다.

이렇게 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. (어떤 개발자는 모든 클래스는 스스로 자신을 테스트하는 main() 메소드를 가지고 있어야 한다고 주장하기도 하지만, 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.)

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 번거로운 작업없이 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수 있다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트

초난감 DAO 코드를 스프링을 이용한 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 테스트였다.

**테스트가 없었다면, 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 그다지 미덥지 않을 수도 있고, 그래서 마음이 불편해지면 이쯤에서 그만두자는 생각이 들 수도 있기 때문.**

또 UserDao의 기능을 추가하려고 할 때도 미리 만들어둔 테스트코드는 유용하게 쓰일 수 있다. 가장 단순한 등록과 조회 기능을 만들고 , 이를 테스트로 검증해서 만든 코드에 대한 확신을 갖는다. 그리고 거기에 조금씩 기능을 추가해가면서 그에 대한 테스트도 함께 추가하는 식으로 점진적인 개발이 가능해진다.

테스트를 이용하면 **새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인** 할 수 도 있다.

</br>

### 2.1.3 UserDaoTest의 문제점

- **수동 확인 작업의 번거로움**
  - add()에서 User 정보를 DB에 등록하고, 이를 다시 get()을 이용해 가져왔을 때 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않음
  - 단지 콘솔에 값만 출력해줄 뿐. 그 콘솔 값을 보고 확인하는 건 사람의 책임
  - 테스트 수행은 코드에 의해 자동으로 진행되지만 테스트의 결과를 확인하는 일은 사람의 책임 → 완전한 자동 테스트 x
- **실행 작업의 번거로움**
  - 간단히 실행 가능한 main() 메소드라도 매번 실행하는 것은 번거로움
  - 수백 개의 DAO가 있고 그에 대한 수백 개의 main() 메소드가 만들어진다면 메소드를 수백 번 실행하는 수고가 필요
  - 이를 종합해서 전체 기능에 대한 테스트 결과를 정리하는 것도 큰 작업이 됨

</br>

## 2.2 UserDaoTest 개선

UserDaoTest의 두 가지 문제점을 개선해보자.

### 2.2.1 테스트 검증의 자동화

모든 테스트는 다음과 같은 결과를 가질 수 있다.

- 성공
- 실패
  - 테스트가 진행되는 동안 에러가 발생하는 경우
  - 결과가 기대한 것과 다르게 나오는 경우

테스트 중에 에러가 발생하는 것은 쉽게 확인 가능. 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다.

기존의 테스트 코드에서는 get()에서 가져온 결과를 사람이 눈으로 확인하도록 단순히 콘솔에 출력하기만 했다면, 이번에는 테스트 코드에서 결과를 직접 확인하고, 기대한 결과와 달라서 실패했을 경우에는 "테스트 실패", 모든 확인 작업을 통과하면 "테스트 성공"이라고 출력하도록 하겠다.

[수정 전]

```java
System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out.println(user2.getId() + " 조회 성공");  
```

[수정 후]

```java
if (!user.getName().equals(user2.getName())) {
  System.out.println("테스트 실패 (name)");
}
else if (!user.getPassword().equals(user2.getPassword())) {
  System.out.println("테스트 실패 (password)");
}
else {
  System.out.println("조회 테스트 성공");
}
```

이렇게 해서 테스트의 수행과 테스트 값 적용, 그리고 결과를 검증하는 것까지 모두 자동화했다.

자동화된 테스트를 위한 xUnit 프레임워크를 만든 켄트 벡은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"이라고 했다. 짧은 시간에 화면에서 하는 수동 테스트로는 당장 수정한 기능의 가장 간단한 케이스를 확인하기에도 벅차기 때문에 전체 기능에 문제가 없는지 점검하는 것은 불가능에 가깝다. 하지만 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트(comprehensive test)를 만들면서부터는, 개발한 애플리케이션은 이후에 어떤 과감한 수정을 하고 나서도 테스트를 통해 코드의 기능 점검뿐 아니라 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치를 취할 수 있다.

이렇게 개발 과정 또는 유지보수를 하면서 기존 애플리케이션 코드에 수정을 할 때 마음의 평안을 얻고, 자신이 만지는 코드에 대해 항상 자신감을 가질 수 있으며, 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것

</br>

### 2.2.2 테스트의 효율적인 수행과 결과 관리

좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메소드로는 한계가 있다. 

- 일정한 패턴을 가진 테스트를 만들 수 있고, 
- 많은 테스트를 간단히 실행시킬 수 있으며, 
- 테스트 결과를 종합해서 볼 수 있고, 
- 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘

테스트 지원 도구과 그에 맞는 테스트 작성 방법이 필요하다. 자바 테스팅 프레임워크라 불리는 JUnit은 이름 그대로 자바로 단위 테스트를 만들 때 유용하게 쓸 수 있다.

#### JUnit 테스트로 전환

지금까지 만들었던 main() 메소드 테스트를 JUnit을 이용해 다시 작성해보자. JUnit은 프레임워크로 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

#### 테스트 메소드 전환

테스트가 main() 메소드 만들어졌다는 건 제어권을 직접 갖는다는 의미. 프레임워크에 적용하기엔 적합하지 않음. 그래서 가장 먼저 할 일은 main() 메소드에 있던 테스트 코드를 일반 메소드로 옮기는 것.

새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 함.

- 메소드가 public으로 선언돼야 함
- 메소드에 @Test라는 어노테이션을 붙여야 함

```java
import org.junit.Test;
...

public class UserDaoTest {

    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);
      	...
    }
}
```

main() 대신 일반 메소드로 만들고 적절한 이름을 붙여준다. 테스트의 의도가 무엇인지 알 수 있는 이름이 좋다.

#### 검증 코드 전환

테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자. UserDaoTest에서 if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용해 다음과 같이 변경할 수 있다.

```java
// before
if (!user.getName().equals(user2.getName())) {...}

// after
assertThat(user2.getName(), is(user.getName()));
```

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 당므으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 매처의 일종으로 euqals()로 비교해주는 기능을 가졌다.

JUnit은 예외가 발생하거나 assertThat()에서 실패하지 않고 테스트 메소드의 실행이 완료된면 테스트가 성공했다고 인식한다. "테스트 성공"이라는 메시지를 굳이 출력할 필요 없이 다양한 방법으로 테스트 결과를 알려준다.

#### JUnit 테스트 실행

JUnit 프레임워크를 이용해 앞에서 만든 테스트 메소드를 실행하도록 코드를 만들어보자. 스프링 컨테이너와 마찬가지로 JUnit 도 어디선가 한 번은 시작시켜줘야 한다. 어디에든 main() 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다.

```java
import org.junit.runner.JUnitCore;
...
public static void main(String[] args) {
  JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

이 클래스를 실행하면 테스트를 실행하는 데 걸린 시간과 테스트 결과, 그리고 몇 개의 테스트 메소드가 실행됐는지를 알려준다. 만약 테스트가 실패하면 OK 대신 FAILURES라는 내용이 출력되고, 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여준다.

JUnit은 assertThat()을 이용해 검증을 했을 때 기대한 결과가 아니면 AssertionError를 던진다. 따라서 assertThat()의 조건을 만족하지 못하면 테스트는 더 이상 진행되지 않고 JUnit은 테스트가 실패했음을 알게 된다. 테스트 수행 중에 일반 예외가 발생한 경우에도 마찬가지다.

